<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Error Explanation â€” Visual Debugger</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="config.js"></script>
</head>

<body>
    <div id="error-panel">
        <!-- Header with category badge -->
        <div class="card-header">
            <h1>ğŸ” Error Explanation</h1>
        </div>

        <!-- Error Location Card -->
        <div class="card slide-in" id="location-card">
            <div class="card-header">
                <span class="badge badge--runtime" id="category-badge">Runtime Error</span>
                <span class="text-muted text-sm" id="error-location">App.tsx, line 15</span>
            </div>
            <p id="error-message"
                style="font-family: var(--vscode-editor-font-family, monospace); background: var(--vscode-textCodeBlock-background, rgba(127,127,127,0.1)); padding: 10px 14px; border-radius: 4px; font-size: 0.92em;">
                TypeError: Cannot read properties of undefined (reading 'map')
            </p>
        </div>

        <!-- What Happened -->
        <div class="card slide-in" id="explanation-card">
            <div class="section">
                <div class="section-title"><span class="icon">ğŸ’¡</span> What Happened</div>
                <div class="section-content" id="explanation-text">
                    You're trying to call <code>.map()</code> on a variable called <code>data</code>, but
                    <code>data</code> is <code>undefined</code>.
                    This means the variable hasn't been assigned a value yet â€” likely because an API call hasn't
                    finished loading when the component tries to render.
                </div>
            </div>
        </div>

        <!-- How to Fix -->
        <div class="card slide-in" id="fix-card">
            <div class="section">
                <div class="section-title"><span class="icon">ğŸ”§</span> How to Fix</div>
                <div class="section-content" id="fix-text">
                    <ol style="padding-left: 18px; margin: 0;">
                        <li>Go to <strong>line 15</strong> in <code>App.tsx</code></li>
                        <li>Initialize your state with an empty array: <code>const [data, setData] = useState([])</code>
                        </li>
                        <li>Or add a guard before <code>.map()</code>: <code>data?.map(...)</code></li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- How to Prevent -->
        <div class="card slide-in" id="prevent-card">
            <div class="section">
                <div class="section-title"><span class="icon">ğŸ›¡ï¸</span> How to Prevent</div>
                <div class="section-content" id="prevent-text">
                    Always initialize state variables with a sensible default value. If a variable will hold an array,
                    initialize it as <code>[]</code>.
                    This prevents <code>undefined</code> errors when your component renders before async data arrives.
                </div>
            </div>
        </div>

        <!-- Best Practices -->
        <div class="card slide-in" id="practices-card">
            <div class="section">
                <div class="section-title"><span class="icon">â­</span> Best Practices</div>
                <div class="section-content" id="practices-text">
                    Use optional chaining (<code>data?.map()</code>) and nullish coalescing (<code>data ?? []</code>) as
                    defensive programming patterns.
                    These are industry-standard approaches to safely handle values that might be <code>null</code> or
                    <code>undefined</code>.
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <div class="card slide-in" id="quiz-card">
            <div class="section">
                <div class="section-title"><span class="icon">ğŸ§ </span> Test Yourself</div>
                <p class="mb-8" id="quiz-question">Why does calling <code>.map()</code> on <code>data</code> throw a
                    TypeError in this case?</p>
                <div class="quiz-options" id="quiz-options">
                    <!-- Options rendered by JS -->
                </div>
                <div class="quiz-feedback" id="quiz-feedback" style="display:none;"></div>
            </div>
        </div>

        <!-- TTS Controls -->
        <div class="mt-12" style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <div
                style="display: flex; border-radius: 6px; overflow: hidden; border: 1px solid var(--vscode-input-border, rgba(127,127,127,0.25));">
                <button class="btn voice-toggle active" id="voice-female"
                    style="border-radius: 0; border: none; padding: 6px 12px; font-size: 0.88em;">ğŸ‘© Female</button>
                <button class="btn voice-toggle" id="voice-male"
                    style="border-radius: 0; border: none; border-left: 1px solid var(--vscode-input-border, rgba(127,127,127,0.25)); padding: 6px 12px; font-size: 0.88em;">ğŸ‘¨
                    Male</button>
            </div>
            <button class="btn btn--secondary" id="tts-btn">ğŸ”Š Read Aloud</button>
        </div>
    </div>

    <script>
        // â”€â”€ State â”€â”€
        let quizAnswered = false;
        let currentErrorData = null;

        // â”€â”€ Main Update Function â”€â”€
        function updatePanel(data) {
            currentErrorData = data;
            quizAnswered = false;

            // 1. Header & Location
            document.getElementById('category-badge').textContent = data.category;
            document.getElementById('category-badge').className = 'badge badge--' + data.category.toLowerCase().replace(/\s+/g, '-');
            document.getElementById('error-location').textContent = data.location;
            document.getElementById('error-message').textContent = data.errorMessage;

            // 2. Content Sections
            document.getElementById('explanation-text').innerHTML = data.explanation; // utilizing innerHTML for bolding if needed, or textContent
            
            // Fix List
            const fixList = data.howToFix.map(step => `<li>${step}</li>`).join('');
            document.getElementById('fix-text').innerHTML = `<ol style="padding-left: 18px; margin: 0;">${fixList}</ol>`;

            document.getElementById('prevent-text').innerHTML = data.howToPrevent; // innerHTML for code tags
            document.getElementById('practices-text').innerHTML = data.bestPractices;

            // 3. Quiz
            const quizCard = document.getElementById('quiz-card');
            if (data.quiz) {
                quizCard.style.display = 'block';
                document.getElementById('quiz-question').innerHTML = data.quiz.question;
                const quizOptions = document.getElementById('quiz-options');
                quizOptions.innerHTML = ''; // clear old options
                document.getElementById('quiz-feedback').style.display = 'none';

                data.quiz.options.forEach((option, index) => {
                    const optionEl = document.createElement('div');
                    optionEl.className = 'quiz-option';
                    optionEl.textContent = option;
                    optionEl.style.animationDelay = (index * 0.06) + 's';
                    optionEl.addEventListener('click', () => {
                        if (quizAnswered) return;
                        quizAnswered = true;

                        // Disable all
                        document.querySelectorAll('.quiz-option').forEach((el, i) => {
                            el.setAttribute('data-answered', 'true');
                            el.style.pointerEvents = 'none';
                            if (i === data.quiz.correct) {
                                el.classList.add('correct');
                            } else if (i === index && i !== data.quiz.correct) {
                                el.classList.add('incorrect');
                            } else {
                                el.style.opacity = '0.5';
                            }
                        });

                        // Feedback
                        const isCorrect = index === data.quiz.correct;
                        const fb = document.getElementById('quiz-feedback');
                        fb.className = 'quiz-feedback ' + (isCorrect ? 'correct' : 'incorrect');
                        fb.textContent = isCorrect 
                            ? 'âœ… ' + data.quiz.explanation 
                            : 'âŒ Not quite. ' + data.quiz.explanation;
                        fb.style.display = 'block';
                        
                        // Notify extension if needed
                         if (window.vscode) {
                            window.vscode.postMessage({ type: 'quizAnswer', correct: isCorrect });
                        }
                    });
                    quizOptions.appendChild(optionEl);
                });
            } else {
                quizCard.style.display = 'none';
            }
            
            // Show content (in case it was hidden)
            document.getElementById('location-card').style.display = 'block';
            document.getElementById('explanation-card').style.display = 'block';
            document.getElementById('fix-card').style.display = 'block';
            document.getElementById('prevent-card').style.display = 'block';
            document.getElementById('practices-card').style.display = 'block';
        }

        // â”€â”€ VS Code Integration â”€â”€
        let vscode;
        try {
            vscode = acquireVsCodeApi();
            window.vscode = vscode;
        } catch (e) {
            console.log("Browser preview mode (no VS Code API)");
        }

        // Listen for messages from extension
        window.addEventListener('message', (event) => {
            const { type, data } = event.data; // Extension sends { type: 'showError', data: {...} }
            if (type === 'showError') {
                updatePanel(data);
            }
        });

        // â”€â”€ Initialization â”€â”€
        const MOCK_ERROR_DATA = {
            category: "Runtime Error",
            location: "App.tsx, line 15",
            errorMessage: "TypeError: Cannot read properties of undefined (reading 'map')",
            explanation: "You're trying to call .map() on a variable called 'data', but 'data' is undefined. This means the variable hasn't been assigned a value yet â€” likely because an API call hasn't finished loading when the component tries to render.",
            howToFix: [
                "Go to line 15 in App.tsx",
                "Initialize your state with an empty array: const [data, setData] = useState([])",
                "Or add a guard before .map(): data?.map(...)"
            ],
            howToPrevent: "Always initialize state variables with a sensible default value. If a variable will hold an array, initialize it as []. This prevents undefined errors when your component renders before async data arrives.",
            bestPractices: "Use optional chaining (data?.map()) and nullish coalescing (data ?? []) as defensive programming patterns. These are industry-standard approaches to safely handle values that might be null or undefined.",
            quiz: {
                question: "Why does calling .map() on 'data' throw a TypeError in this case?",
                options: [
                    "A) .map() is not a valid JavaScript method",
                    "B) 'data' is undefined because the state wasn't initialized with a default value",
                    "C) The API returned an error",
                    "D) .map() only works on strings, not arrays"
                ],
                correct: 1, // B (0-indexed)
                explanation: "Correct! The state variable 'data' was not given a default value (like []), so it starts as undefined. When React tries to render before the API data arrives, it calls .map() on undefined, which crashes."
            }
        };

        // If in browser (no vscode), load mock data immediately for preview
        if (!vscode) {
            updatePanel(MOCK_ERROR_DATA);
        } else {
             // In VS Code, we wait for a message. Optionally show a "Waiting..." state or keeping empty.
             // But for now, let's just do nothing and let the extension push data.
        }

        // â”€â”€ ElevenLabs TTS â€” Natural Voice Integration â”€â”€
        // Voices: Rachel (female), Josh (male) â€” both sound natural & clear
        const VOICES = {
            female: { id: '21m00Tcm4TlvDq8ikWAM', name: 'Rachel' },
            male: { id: 'TxGEqnHWrfWFTfGW9XjX', name: 'Josh' }
        };
        let selectedVoice = 'female';
        
        // Voice toggle buttons
        const voiceFemaleBtn = document.getElementById('voice-female');
        const voiceMaleBtn = document.getElementById('voice-male');
        
        voiceFemaleBtn.addEventListener('click', () => {
            selectedVoice = 'female';
            voiceFemaleBtn.classList.add('active');
            voiceMaleBtn.classList.remove('active');
        });
        voiceMaleBtn.addEventListener('click', () => {
            selectedVoice = 'male';
            voiceMaleBtn.classList.add('active');
            voiceFemaleBtn.classList.remove('active');
        });

        const ttsBtn = document.getElementById('tts-btn');
        let ttsAudio = null;
        let isSpeaking = false;

        ttsBtn.addEventListener('click', async () => {
            // Toggle off if already speaking
            if (isSpeaking && ttsAudio) {
                ttsAudio.pause();
                ttsAudio = null;
                isSpeaking = false;
                ttsBtn.textContent = 'ğŸ”Š Read Aloud';
                ttsBtn.classList.remove('btn--tts-playing');
                return;
            }

            // Gather explanation text
            const data = currentErrorData || MOCK_ERROR_DATA; // use current data
            const textToRead = [
                data.explanation,
                'How to fix it: ' + data.howToFix.join('. '),
                'How to prevent it: ' + data.howToPrevent,
            ].join('. ');

            // Use API key from config.js, fall back to browser speech
            const apiKey = (typeof ELEVENLABS_API_KEY !== 'undefined' && ELEVENLABS_API_KEY !== 'your_api_key_here')
                ? ELEVENLABS_API_KEY : null;

            ttsBtn.textContent = 'â³ Loading...';
            ttsBtn.classList.add('btn--tts-loading');

            if (apiKey) {
                try {
                    const voice = VOICES[selectedVoice];
                    const res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice.id}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'xi-api-key': apiKey },
                        body: JSON.stringify({
                            text: textToRead,
                            model_id: 'eleven_multilingual_v2',
                            voice_settings: {
                                stability: 0.65,
                                similarity_boost: 0.80,
                                style: 0.35,
                                use_speaker_boost: true
                            }
                        })
                    });
                    if (!res.ok) throw new Error('API error ' + res.status);
                    const blob = await res.blob();
                    const url = URL.createObjectURL(blob);
                    ttsAudio = new Audio(url);
                    isSpeaking = true;
                    ttsBtn.textContent = 'â¹ï¸ Stop';
                    ttsBtn.classList.remove('btn--tts-loading');
                    ttsBtn.classList.add('btn--tts-playing');
                    ttsAudio.onended = () => {
                        isSpeaking = false;
                        ttsBtn.textContent = 'ğŸ”Š Read Aloud';
                        ttsBtn.classList.remove('btn--tts-playing');
                        URL.revokeObjectURL(url);
                    };
                    ttsAudio.play();
                    return;
                } catch (e) {
                    console.warn('ElevenLabs failed, falling back to browser TTS:', e);
                }
            }

            // Fallback: browser SpeechSynthesis
            ttsBtn.classList.remove('btn--tts-loading');
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(textToRead);
                utterance.rate = 0.95;
                isSpeaking = true;
                ttsBtn.textContent = 'â¹ï¸ Stop';
                ttsBtn.classList.add('btn--tts-playing');
                utterance.onend = () => { isSpeaking = false; ttsBtn.textContent = 'ğŸ”Š Read Aloud'; ttsBtn.classList.remove('btn--tts-playing'); };
                speechSynthesis.speak(utterance);
            } else {
                ttsBtn.textContent = 'ğŸ”Š Read Aloud';
                alert('TTS not available in this browser.');
            }
        });
    </script>
</body>

</html>